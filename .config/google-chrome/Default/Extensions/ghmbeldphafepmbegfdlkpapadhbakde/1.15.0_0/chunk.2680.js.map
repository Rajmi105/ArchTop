{"version":3,"file":"chunk.2680.js","mappings":"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","sources":["webpack://proton-pass-extension/../../node_modules/pmcrypto/node_modules/@openpgp/asmcrypto.js/dist_es8/aes/aes.asm.js","webpack://proton-pass-extension/../../node_modules/pmcrypto/node_modules/@openpgp/asmcrypto.js/dist_es8/aes/aes.js","webpack://proton-pass-extension/../../node_modules/pmcrypto/node_modules/@openpgp/asmcrypto.js/dist_es8/aes/cfb.js","webpack://proton-pass-extension/../../node_modules/pmcrypto/lib/crypto/cfb.js","webpack://proton-pass-extension/../../node_modules/pmcrypto/node_modules/@openpgp/asmcrypto.js/dist_es8/other/errors.js","webpack://proton-pass-extension/../../node_modules/pmcrypto/node_modules/@openpgp/asmcrypto.js/dist_es8/other/utils.js"],"sourcesContent":["/**\n * @file {@link http://asmjs.org Asm.js} implementation of the {@link https://en.wikipedia.org/wiki/Advanced_Encryption_Standard Advanced Encryption Standard}.\n * @author Artem S Vybornov <vybornov@gmail.com>\n * @license MIT\n */\nexport var AES_asm = function () {\n  \"use strict\";\n\n  /**\n   * Galois Field stuff init flag\n   */\n  var ginit_done = false;\n\n  /**\n   * Galois Field exponentiation and logarithm tables for 3 (the generator)\n   */\n  var gexp3, glog3;\n\n  /**\n   * Init Galois Field tables\n   */\n  function ginit() {\n    gexp3 = [],\n      glog3 = [];\n\n    var a = 1, c, d;\n    for (c = 0; c < 255; c++) {\n      gexp3[c] = a;\n\n      // Multiply by three\n      d = a & 0x80, a <<= 1, a &= 255;\n      if (d === 0x80) a ^= 0x1b;\n      a ^= gexp3[c];\n\n      // Set the log table value\n      glog3[gexp3[c]] = c;\n    }\n    gexp3[255] = gexp3[0];\n    glog3[0] = 0;\n\n    ginit_done = true;\n  }\n\n  /**\n   * Galois Field multiplication\n   * @param {number} a\n   * @param {number} b\n   * @return {number}\n   */\n  function gmul(a, b) {\n    var c = gexp3[(glog3[a] + glog3[b]) % 255];\n    if (a === 0 || b === 0) c = 0;\n    return c;\n  }\n\n  /**\n   * Galois Field reciprocal\n   * @param {number} a\n   * @return {number}\n   */\n  function ginv(a) {\n    var i = gexp3[255 - glog3[a]];\n    if (a === 0) i = 0;\n    return i;\n  }\n\n  /**\n   * AES stuff init flag\n   */\n  var aes_init_done = false;\n\n  /**\n   * Encryption, Decryption, S-Box and KeyTransform tables\n   *\n   * @type {number[]}\n   */\n  var aes_sbox;\n\n  /**\n   * @type {number[]}\n   */\n  var aes_sinv;\n\n  /**\n   * @type {number[][]}\n   */\n  var aes_enc;\n\n  /**\n   * @type {number[][]}\n   */\n  var aes_dec;\n\n  /**\n   * Init AES tables\n   */\n  function aes_init() {\n    if (!ginit_done) ginit();\n\n    // Calculates AES S-Box value\n    function _s(a) {\n      var c, s, x;\n      s = x = ginv(a);\n      for (c = 0; c < 4; c++) {\n        s = ((s << 1) | (s >>> 7)) & 255;\n        x ^= s;\n      }\n      x ^= 99;\n      return x;\n    }\n\n    // Tables\n    aes_sbox = [],\n      aes_sinv = [],\n      aes_enc = [[], [], [], []],\n      aes_dec = [[], [], [], []];\n\n    for (var i = 0; i < 256; i++) {\n      var s = _s(i);\n\n      // S-Box and its inverse\n      aes_sbox[i] = s;\n      aes_sinv[s] = i;\n\n      // Ecryption and Decryption tables\n      aes_enc[0][i] = (gmul(2, s) << 24) | (s << 16) | (s << 8) | gmul(3, s);\n      aes_dec[0][s] = (gmul(14, i) << 24) | (gmul(9, i) << 16) | (gmul(13, i) << 8) | gmul(11, i);\n      // Rotate tables\n      for (var t = 1; t < 4; t++) {\n        aes_enc[t][i] = (aes_enc[t - 1][i] >>> 8) | (aes_enc[t - 1][i] << 24);\n        aes_dec[t][s] = (aes_dec[t - 1][s] >>> 8) | (aes_dec[t - 1][s] << 24);\n      }\n    }\n\n    aes_init_done = true;\n  }\n\n  /**\n   * Asm.js module constructor.\n   *\n   * <p>\n   * Heap buffer layout by offset:\n   * <pre>\n   * 0x0000   encryption key schedule\n   * 0x0400   decryption key schedule\n   * 0x0800   sbox\n   * 0x0c00   inv sbox\n   * 0x1000   encryption tables\n   * 0x2000   decryption tables\n   * 0x3000   reserved (future GCM multiplication lookup table)\n   * 0x4000   data\n   * </pre>\n   * Don't touch anything before <code>0x400</code>.\n   * </p>\n   *\n   * @alias AES_asm\n   * @class\n   * @param foreign - <i>ignored</i>\n   * @param buffer - heap buffer to link with\n   */\n  var wrapper = function (foreign, buffer) {\n    // Init AES stuff for the first time\n    if (!aes_init_done) aes_init();\n\n    // Fill up AES tables\n    var heap = new Uint32Array(buffer);\n    heap.set(aes_sbox, 0x0800 >> 2);\n    heap.set(aes_sinv, 0x0c00 >> 2);\n    for (var i = 0; i < 4; i++) {\n      heap.set(aes_enc[i], (0x1000 + 0x400 * i) >> 2);\n      heap.set(aes_dec[i], (0x2000 + 0x400 * i) >> 2);\n    }\n\n    /**\n     * Calculate AES key schedules.\n     * @instance\n     * @memberof AES_asm\n     * @param {number} ks - key size, 4/6/8 (for 128/192/256-bit key correspondingly)\n     * @param {number} k0 - key vector components\n     * @param {number} k1 - key vector components\n     * @param {number} k2 - key vector components\n     * @param {number} k3 - key vector components\n     * @param {number} k4 - key vector components\n     * @param {number} k5 - key vector components\n     * @param {number} k6 - key vector components\n     * @param {number} k7 - key vector components\n     */\n    function set_key(ks, k0, k1, k2, k3, k4, k5, k6, k7) {\n      var ekeys = heap.subarray(0x000, 60),\n        dkeys = heap.subarray(0x100, 0x100 + 60);\n\n      // Encryption key schedule\n      ekeys.set([k0, k1, k2, k3, k4, k5, k6, k7]);\n      for (var i = ks, rcon = 1; i < 4 * ks + 28; i++) {\n        var k = ekeys[i - 1];\n        if ((i % ks === 0) || (ks === 8 && i % ks === 4)) {\n          k = aes_sbox[k >>> 24] << 24 ^ aes_sbox[k >>> 16 & 255] << 16 ^ aes_sbox[k >>> 8 & 255] << 8 ^ aes_sbox[k & 255];\n        }\n        if (i % ks === 0) {\n          k = (k << 8) ^ (k >>> 24) ^ (rcon << 24);\n          rcon = (rcon << 1) ^ ((rcon & 0x80) ? 0x1b : 0);\n        }\n        ekeys[i] = ekeys[i - ks] ^ k;\n      }\n\n      // Decryption key schedule\n      for (var j = 0; j < i; j += 4) {\n        for (var jj = 0; jj < 4; jj++) {\n          var k = ekeys[i - (4 + j) + (4 - jj) % 4];\n          if (j < 4 || j >= i - 4) {\n            dkeys[j + jj] = k;\n          } else {\n            dkeys[j + jj] = aes_dec[0][aes_sbox[k >>> 24]]\n              ^ aes_dec[1][aes_sbox[k >>> 16 & 255]]\n              ^ aes_dec[2][aes_sbox[k >>> 8 & 255]]\n              ^ aes_dec[3][aes_sbox[k & 255]];\n          }\n        }\n      }\n\n      // Set rounds number\n      asm.set_rounds(ks + 5);\n    }\n\n    // create library object with necessary properties\n    var stdlib = {Uint8Array: Uint8Array, Uint32Array: Uint32Array};\n\n    var asm = function (stdlib, foreign, buffer) {\n      \"use asm\";\n\n      var S0 = 0, S1 = 0, S2 = 0, S3 = 0,\n        I0 = 0, I1 = 0, I2 = 0, I3 = 0,\n        N0 = 0, N1 = 0, N2 = 0, N3 = 0,\n        M0 = 0, M1 = 0, M2 = 0, M3 = 0,\n        H0 = 0, H1 = 0, H2 = 0, H3 = 0,\n        R = 0;\n\n      var HEAP = new stdlib.Uint32Array(buffer),\n        DATA = new stdlib.Uint8Array(buffer);\n\n      /**\n       * AES core\n       * @param {number} k - precomputed key schedule offset\n       * @param {number} s - precomputed sbox table offset\n       * @param {number} t - precomputed round table offset\n       * @param {number} r - number of inner rounds to perform\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _core(k, s, t, r, x0, x1, x2, x3) {\n        k = k | 0;\n        s = s | 0;\n        t = t | 0;\n        r = r | 0;\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        var t1 = 0, t2 = 0, t3 = 0,\n          y0 = 0, y1 = 0, y2 = 0, y3 = 0,\n          i = 0;\n\n        t1 = t | 0x400, t2 = t | 0x800, t3 = t | 0xc00;\n\n        // round 0\n        x0 = x0 ^ HEAP[(k | 0) >> 2],\n          x1 = x1 ^ HEAP[(k | 4) >> 2],\n          x2 = x2 ^ HEAP[(k | 8) >> 2],\n          x3 = x3 ^ HEAP[(k | 12) >> 2];\n\n        // round 1..r\n        for (i = 16; (i | 0) <= (r << 4); i = (i + 16) | 0) {\n          y0 = HEAP[(t | x0 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x1 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x2 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i | 0) >> 2],\n            y1 = HEAP[(t | x1 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x2 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x3 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i | 4) >> 2],\n            y2 = HEAP[(t | x2 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x3 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x0 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i | 8) >> 2],\n            y3 = HEAP[(t | x3 >> 22 & 1020) >> 2] ^ HEAP[(t1 | x0 >> 14 & 1020) >> 2] ^ HEAP[(t2 | x1 >> 6 & 1020) >> 2] ^ HEAP[(t3 | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i | 12) >> 2];\n          x0 = y0, x1 = y1, x2 = y2, x3 = y3;\n        }\n\n        // final round\n        S0 = HEAP[(s | x0 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x1 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x2 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x3 << 2 & 1020) >> 2] ^ HEAP[(k | i | 0) >> 2],\n          S1 = HEAP[(s | x1 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x2 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x3 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x0 << 2 & 1020) >> 2] ^ HEAP[(k | i | 4) >> 2],\n          S2 = HEAP[(s | x2 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x3 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x0 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x1 << 2 & 1020) >> 2] ^ HEAP[(k | i | 8) >> 2],\n          S3 = HEAP[(s | x3 >> 22 & 1020) >> 2] << 24 ^ HEAP[(s | x0 >> 14 & 1020) >> 2] << 16 ^ HEAP[(s | x1 >> 6 & 1020) >> 2] << 8 ^ HEAP[(s | x2 << 2 & 1020) >> 2] ^ HEAP[(k | i | 12) >> 2];\n      }\n\n      /**\n       * ECB mode encryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _ecb_enc(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          x0,\n          x1,\n          x2,\n          x3\n        );\n      }\n\n      /**\n       * ECB mode decryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _ecb_dec(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        var t = 0;\n\n        _core(\n          0x0400, 0x0c00, 0x2000,\n          R,\n          x0,\n          x3,\n          x2,\n          x1\n        );\n\n        t = S1, S1 = S3, S3 = t;\n      }\n\n\n      /**\n       * CBC mode encryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _cbc_enc(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          I0 ^ x0,\n          I1 ^ x1,\n          I2 ^ x2,\n          I3 ^ x3\n        );\n\n        I0 = S0,\n          I1 = S1,\n          I2 = S2,\n          I3 = S3;\n      }\n\n      /**\n       * CBC mode decryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _cbc_dec(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        var t = 0;\n\n        _core(\n          0x0400, 0x0c00, 0x2000,\n          R,\n          x0,\n          x3,\n          x2,\n          x1\n        );\n\n        t = S1, S1 = S3, S3 = t;\n\n        S0 = S0 ^ I0,\n          S1 = S1 ^ I1,\n          S2 = S2 ^ I2,\n          S3 = S3 ^ I3;\n\n        I0 = x0,\n          I1 = x1,\n          I2 = x2,\n          I3 = x3;\n      }\n\n      /**\n       * CFB mode encryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _cfb_enc(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          I0,\n          I1,\n          I2,\n          I3\n        );\n\n        I0 = S0 = S0 ^ x0,\n          I1 = S1 = S1 ^ x1,\n          I2 = S2 = S2 ^ x2,\n          I3 = S3 = S3 ^ x3;\n      }\n\n\n      /**\n       * CFB mode decryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _cfb_dec(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          I0,\n          I1,\n          I2,\n          I3\n        );\n\n        S0 = S0 ^ x0,\n          S1 = S1 ^ x1,\n          S2 = S2 ^ x2,\n          S3 = S3 ^ x3;\n\n        I0 = x0,\n          I1 = x1,\n          I2 = x2,\n          I3 = x3;\n      }\n\n      /**\n       * OFB mode encryption / decryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _ofb(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          I0,\n          I1,\n          I2,\n          I3\n        );\n\n        I0 = S0,\n          I1 = S1,\n          I2 = S2,\n          I3 = S3;\n\n        S0 = S0 ^ x0,\n          S1 = S1 ^ x1,\n          S2 = S2 ^ x2,\n          S3 = S3 ^ x3;\n      }\n\n      /**\n       * CTR mode encryption / decryption\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _ctr(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        _core(\n          0x0000, 0x0800, 0x1000,\n          R,\n          N0,\n          N1,\n          N2,\n          N3\n        );\n\n        N3 = (~M3 & N3) | M3 & (N3 + 1);\n          N2 = (~M2 & N2) | M2 & (N2 + ((N3 | 0) == 0));\n          N1 = (~M1 & N1) | M1 & (N1 + ((N2 | 0) == 0));\n          N0 = (~M0 & N0) | M0 & (N0 + ((N1 | 0) == 0));\n\n        S0 = S0 ^ x0;\n          S1 = S1 ^ x1;\n          S2 = S2 ^ x2;\n          S3 = S3 ^ x3;\n      }\n\n      /**\n       * GCM mode MAC calculation\n       * @param {number} x0 - 128-bit input block vector\n       * @param {number} x1 - 128-bit input block vector\n       * @param {number} x2 - 128-bit input block vector\n       * @param {number} x3 - 128-bit input block vector\n       */\n      function _gcm_mac(x0, x1, x2, x3) {\n        x0 = x0 | 0;\n        x1 = x1 | 0;\n        x2 = x2 | 0;\n        x3 = x3 | 0;\n\n        var y0 = 0, y1 = 0, y2 = 0, y3 = 0,\n          z0 = 0, z1 = 0, z2 = 0, z3 = 0,\n          i = 0, c = 0;\n\n        x0 = x0 ^ I0,\n          x1 = x1 ^ I1,\n          x2 = x2 ^ I2,\n          x3 = x3 ^ I3;\n\n        y0 = H0 | 0,\n          y1 = H1 | 0,\n          y2 = H2 | 0,\n          y3 = H3 | 0;\n\n        for (; (i | 0) < 128; i = (i + 1) | 0) {\n          if (y0 >>> 31) {\n            z0 = z0 ^ x0,\n              z1 = z1 ^ x1,\n              z2 = z2 ^ x2,\n              z3 = z3 ^ x3;\n          }\n\n          y0 = (y0 << 1) | (y1 >>> 31),\n            y1 = (y1 << 1) | (y2 >>> 31),\n            y2 = (y2 << 1) | (y3 >>> 31),\n            y3 = (y3 << 1);\n\n          c = x3 & 1;\n\n          x3 = (x3 >>> 1) | (x2 << 31),\n            x2 = (x2 >>> 1) | (x1 << 31),\n            x1 = (x1 >>> 1) | (x0 << 31),\n            x0 = (x0 >>> 1);\n\n          if (c) x0 = x0 ^ 0xe1000000;\n        }\n\n        I0 = z0,\n          I1 = z1,\n          I2 = z2,\n          I3 = z3;\n      }\n\n      /**\n       * Set the internal rounds number.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} r - number if inner AES rounds\n       */\n      function set_rounds(r) {\n        r = r | 0;\n        R = r;\n      }\n\n      /**\n       * Populate the internal state of the module.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} s0 - state vector\n       * @param {number} s1 - state vector\n       * @param {number} s2 - state vector\n       * @param {number} s3 - state vector\n       */\n      function set_state(s0, s1, s2, s3) {\n        s0 = s0 | 0;\n        s1 = s1 | 0;\n        s2 = s2 | 0;\n        s3 = s3 | 0;\n\n        S0 = s0,\n          S1 = s1,\n          S2 = s2,\n          S3 = s3;\n      }\n\n      /**\n       * Populate the internal iv of the module.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} i0 - iv vector\n       * @param {number} i1 - iv vector\n       * @param {number} i2 - iv vector\n       * @param {number} i3 - iv vector\n       */\n      function set_iv(i0, i1, i2, i3) {\n        i0 = i0 | 0;\n        i1 = i1 | 0;\n        i2 = i2 | 0;\n        i3 = i3 | 0;\n\n        I0 = i0,\n          I1 = i1,\n          I2 = i2,\n          I3 = i3;\n      }\n\n      /**\n       * Set nonce for CTR-family modes.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} n0 - nonce vector\n       * @param {number} n1 - nonce vector\n       * @param {number} n2 - nonce vector\n       * @param {number} n3 - nonce vector\n       */\n      function set_nonce(n0, n1, n2, n3) {\n        n0 = n0 | 0;\n        n1 = n1 | 0;\n        n2 = n2 | 0;\n        n3 = n3 | 0;\n\n        N0 = n0,\n          N1 = n1,\n          N2 = n2,\n          N3 = n3;\n      }\n\n      /**\n       * Set counter mask for CTR-family modes.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} m0 - counter mask vector\n       * @param {number} m1 - counter mask vector\n       * @param {number} m2 - counter mask vector\n       * @param {number} m3 - counter mask vector\n       */\n      function set_mask(m0, m1, m2, m3) {\n        m0 = m0 | 0;\n        m1 = m1 | 0;\n        m2 = m2 | 0;\n        m3 = m3 | 0;\n\n        M0 = m0,\n          M1 = m1,\n          M2 = m2,\n          M3 = m3;\n      }\n\n      /**\n       * Set counter for CTR-family modes.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} c0 - counter vector\n       * @param {number} c1 - counter vector\n       * @param {number} c2 - counter vector\n       * @param {number} c3 - counter vector\n       */\n      function set_counter(c0, c1, c2, c3) {\n        c0 = c0 | 0;\n        c1 = c1 | 0;\n        c2 = c2 | 0;\n        c3 = c3 | 0;\n\n        N3 = (~M3 & N3) | M3 & c3,\n          N2 = (~M2 & N2) | M2 & c2,\n          N1 = (~M1 & N1) | M1 & c1,\n          N0 = (~M0 & N0) | M0 & c0;\n      }\n\n      /**\n       * Store the internal state vector into the heap.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} pos - offset where to put the data\n       * @return {number} The number of bytes have been written into the heap, always 16.\n       */\n      function get_state(pos) {\n        pos = pos | 0;\n\n        if (pos & 15) return -1;\n\n        DATA[pos | 0] = S0 >>> 24,\n          DATA[pos | 1] = S0 >>> 16 & 255,\n          DATA[pos | 2] = S0 >>> 8 & 255,\n          DATA[pos | 3] = S0 & 255,\n          DATA[pos | 4] = S1 >>> 24,\n          DATA[pos | 5] = S1 >>> 16 & 255,\n          DATA[pos | 6] = S1 >>> 8 & 255,\n          DATA[pos | 7] = S1 & 255,\n          DATA[pos | 8] = S2 >>> 24,\n          DATA[pos | 9] = S2 >>> 16 & 255,\n          DATA[pos | 10] = S2 >>> 8 & 255,\n          DATA[pos | 11] = S2 & 255,\n          DATA[pos | 12] = S3 >>> 24,\n          DATA[pos | 13] = S3 >>> 16 & 255,\n          DATA[pos | 14] = S3 >>> 8 & 255,\n          DATA[pos | 15] = S3 & 255;\n\n        return 16;\n      }\n\n      /**\n       * Store the internal iv vector into the heap.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} pos - offset where to put the data\n       * @return {number} The number of bytes have been written into the heap, always 16.\n       */\n      function get_iv(pos) {\n        pos = pos | 0;\n\n        if (pos & 15) return -1;\n\n        DATA[pos | 0] = I0 >>> 24,\n          DATA[pos | 1] = I0 >>> 16 & 255,\n          DATA[pos | 2] = I0 >>> 8 & 255,\n          DATA[pos | 3] = I0 & 255,\n          DATA[pos | 4] = I1 >>> 24,\n          DATA[pos | 5] = I1 >>> 16 & 255,\n          DATA[pos | 6] = I1 >>> 8 & 255,\n          DATA[pos | 7] = I1 & 255,\n          DATA[pos | 8] = I2 >>> 24,\n          DATA[pos | 9] = I2 >>> 16 & 255,\n          DATA[pos | 10] = I2 >>> 8 & 255,\n          DATA[pos | 11] = I2 & 255,\n          DATA[pos | 12] = I3 >>> 24,\n          DATA[pos | 13] = I3 >>> 16 & 255,\n          DATA[pos | 14] = I3 >>> 8 & 255,\n          DATA[pos | 15] = I3 & 255;\n\n        return 16;\n      }\n\n      /**\n       * GCM initialization.\n       * @instance\n       * @memberof AES_asm\n       */\n      function gcm_init() {\n        _ecb_enc(0, 0, 0, 0);\n        H0 = S0,\n          H1 = S1,\n          H2 = S2,\n          H3 = S3;\n      }\n\n      /**\n       * Perform ciphering operation on the supplied data.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} mode - block cipher mode (see {@link AES_asm} mode constants)\n       * @param {number} pos - offset of the data being processed\n       * @param {number} len - length of the data being processed\n       * @return {number} Actual amount of data have been processed.\n       */\n      function cipher(mode, pos, len) {\n        mode = mode | 0;\n        pos = pos | 0;\n        len = len | 0;\n\n        var ret = 0;\n\n        if (pos & 15) return -1;\n\n        while ((len | 0) >= 16) {\n          _cipher_modes[mode & 7](\n            DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3],\n            DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7],\n            DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11],\n            DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]\n          );\n\n          DATA[pos | 0] = S0 >>> 24,\n            DATA[pos | 1] = S0 >>> 16 & 255,\n            DATA[pos | 2] = S0 >>> 8 & 255,\n            DATA[pos | 3] = S0 & 255,\n            DATA[pos | 4] = S1 >>> 24,\n            DATA[pos | 5] = S1 >>> 16 & 255,\n            DATA[pos | 6] = S1 >>> 8 & 255,\n            DATA[pos | 7] = S1 & 255,\n            DATA[pos | 8] = S2 >>> 24,\n            DATA[pos | 9] = S2 >>> 16 & 255,\n            DATA[pos | 10] = S2 >>> 8 & 255,\n            DATA[pos | 11] = S2 & 255,\n            DATA[pos | 12] = S3 >>> 24,\n            DATA[pos | 13] = S3 >>> 16 & 255,\n            DATA[pos | 14] = S3 >>> 8 & 255,\n            DATA[pos | 15] = S3 & 255;\n\n          ret = (ret + 16) | 0,\n            pos = (pos + 16) | 0,\n            len = (len - 16) | 0;\n        }\n\n        return ret | 0;\n      }\n\n      /**\n       * Calculates MAC of the supplied data.\n       * @instance\n       * @memberof AES_asm\n       * @param {number} mode - block cipher mode (see {@link AES_asm} mode constants)\n       * @param {number} pos - offset of the data being processed\n       * @param {number} len - length of the data being processed\n       * @return {number} Actual amount of data have been processed.\n       */\n      function mac(mode, pos, len) {\n        mode = mode | 0;\n        pos = pos | 0;\n        len = len | 0;\n\n        var ret = 0;\n\n        if (pos & 15) return -1;\n\n        while ((len | 0) >= 16) {\n          _mac_modes[mode & 1](\n            DATA[pos | 0] << 24 | DATA[pos | 1] << 16 | DATA[pos | 2] << 8 | DATA[pos | 3],\n            DATA[pos | 4] << 24 | DATA[pos | 5] << 16 | DATA[pos | 6] << 8 | DATA[pos | 7],\n            DATA[pos | 8] << 24 | DATA[pos | 9] << 16 | DATA[pos | 10] << 8 | DATA[pos | 11],\n            DATA[pos | 12] << 24 | DATA[pos | 13] << 16 | DATA[pos | 14] << 8 | DATA[pos | 15]\n          );\n\n          ret = (ret + 16) | 0,\n            pos = (pos + 16) | 0,\n            len = (len - 16) | 0;\n        }\n\n        return ret | 0;\n      }\n\n      /**\n       * AES cipher modes table (virual methods)\n       */\n      var _cipher_modes = [_ecb_enc, _ecb_dec, _cbc_enc, _cbc_dec, _cfb_enc, _cfb_dec, _ofb, _ctr];\n\n      /**\n       * AES MAC modes table (virual methods)\n       */\n      var _mac_modes = [_cbc_enc, _gcm_mac];\n\n      /**\n       * Asm.js module exports\n       */\n      return {\n        set_rounds: set_rounds,\n        set_state: set_state,\n        set_iv: set_iv,\n        set_nonce: set_nonce,\n        set_mask: set_mask,\n        set_counter: set_counter,\n        get_state: get_state,\n        get_iv: get_iv,\n        gcm_init: gcm_init,\n        cipher: cipher,\n        mac: mac,\n      };\n    }(stdlib, foreign, buffer);\n\n    asm.set_key = set_key;\n\n    return asm;\n  };\n\n  /**\n   * AES enciphering mode constants\n   * @enum {number}\n   * @const\n   */\n  wrapper.ENC = {\n    ECB: 0,\n    CBC: 2,\n    CFB: 4,\n    OFB: 6,\n    CTR: 7,\n  },\n\n    /**\n     * AES deciphering mode constants\n     * @enum {number}\n     * @const\n     */\n    wrapper.DEC = {\n      ECB: 1,\n      CBC: 3,\n      CFB: 5,\n      OFB: 6,\n      CTR: 7,\n    },\n\n    /**\n     * AES MAC mode constants\n     * @enum {number}\n     * @const\n     */\n    wrapper.MAC = {\n      CBC: 0,\n      GCM: 1,\n    };\n\n  /**\n   * Heap data offset\n   * @type {number}\n   * @const\n   */\n  wrapper.HEAP_DATA = 0x4000;\n\n  return wrapper;\n}();\n","import { AES_asm } from './aes.asm';\nimport { _heap_init, _heap_write, is_bytes } from '../other/utils';\nimport { IllegalArgumentError, SecurityError } from '../other/errors';\nconst heap_pool = [];\nconst asm_pool = [];\nexport class AES {\n    constructor(key, iv, padding = true, mode, heap, asm) {\n        this.pos = 0;\n        this.len = 0;\n        this.mode = mode;\n        // The AES object state\n        this.pos = 0;\n        this.len = 0;\n        this.key = key;\n        this.iv = iv;\n        this.padding = padding;\n        // The AES \"worker\"\n        this.acquire_asm(heap, asm);\n    }\n    acquire_asm(heap, asm) {\n        if (this.heap === undefined || this.asm === undefined) {\n            this.heap = heap || heap_pool.pop() || _heap_init().subarray(AES_asm.HEAP_DATA);\n            this.asm = asm || asm_pool.pop() || new AES_asm(null, this.heap.buffer);\n            this.reset(this.key, this.iv);\n        }\n        return { heap: this.heap, asm: this.asm };\n    }\n    release_asm() {\n        if (this.heap !== undefined && this.asm !== undefined) {\n            heap_pool.push(this.heap);\n            asm_pool.push(this.asm);\n        }\n        this.heap = undefined;\n        this.asm = undefined;\n    }\n    reset(key, iv) {\n        const { asm } = this.acquire_asm();\n        // Key\n        const keylen = key.length;\n        if (keylen !== 16 && keylen !== 24 && keylen !== 32)\n            throw new IllegalArgumentError('illegal key size');\n        const keyview = new DataView(key.buffer, key.byteOffset, key.byteLength);\n        asm.set_key(keylen >> 2, keyview.getUint32(0), keyview.getUint32(4), keyview.getUint32(8), keyview.getUint32(12), keylen > 16 ? keyview.getUint32(16) : 0, keylen > 16 ? keyview.getUint32(20) : 0, keylen > 24 ? keyview.getUint32(24) : 0, keylen > 24 ? keyview.getUint32(28) : 0);\n        // IV\n        if (iv !== undefined) {\n            if (iv.length !== 16)\n                throw new IllegalArgumentError('illegal iv size');\n            let ivview = new DataView(iv.buffer, iv.byteOffset, iv.byteLength);\n            asm.set_iv(ivview.getUint32(0), ivview.getUint32(4), ivview.getUint32(8), ivview.getUint32(12));\n        }\n        else {\n            asm.set_iv(0, 0, 0, 0);\n        }\n    }\n    AES_Encrypt_process(data) {\n        if (!is_bytes(data))\n            throw new TypeError(\"data isn't of expected type\");\n        let { heap, asm } = this.acquire_asm();\n        let amode = AES_asm.ENC[this.mode];\n        let hpos = AES_asm.HEAP_DATA;\n        let pos = this.pos;\n        let len = this.len;\n        let dpos = 0;\n        let dlen = data.length || 0;\n        let rpos = 0;\n        let rlen = (len + dlen) & -16;\n        let wlen = 0;\n        let result = new Uint8Array(rlen);\n        while (dlen > 0) {\n            wlen = _heap_write(heap, pos + len, data, dpos, dlen);\n            len += wlen;\n            dpos += wlen;\n            dlen -= wlen;\n            wlen = asm.cipher(amode, hpos + pos, len);\n            if (wlen)\n                result.set(heap.subarray(pos, pos + wlen), rpos);\n            rpos += wlen;\n            if (wlen < len) {\n                pos += wlen;\n                len -= wlen;\n            }\n            else {\n                pos = 0;\n                len = 0;\n            }\n        }\n        this.pos = pos;\n        this.len = len;\n        return result;\n    }\n    AES_Encrypt_finish() {\n        let { heap, asm } = this.acquire_asm();\n        let amode = AES_asm.ENC[this.mode];\n        let hpos = AES_asm.HEAP_DATA;\n        let pos = this.pos;\n        let len = this.len;\n        let plen = 16 - (len % 16);\n        let rlen = len;\n        if (this.hasOwnProperty('padding')) {\n            if (this.padding) {\n                for (let p = 0; p < plen; ++p) {\n                    heap[pos + len + p] = plen;\n                }\n                len += plen;\n                rlen = len;\n            }\n            else if (len % 16) {\n                throw new IllegalArgumentError('data length must be a multiple of the block size');\n            }\n        }\n        else {\n            len += plen;\n        }\n        const result = new Uint8Array(rlen);\n        if (len)\n            asm.cipher(amode, hpos + pos, len);\n        if (rlen)\n            result.set(heap.subarray(pos, pos + rlen));\n        this.pos = 0;\n        this.len = 0;\n        this.release_asm();\n        return result;\n    }\n    AES_Decrypt_process(data) {\n        if (!is_bytes(data))\n            throw new TypeError(\"data isn't of expected type\");\n        let { heap, asm } = this.acquire_asm();\n        let amode = AES_asm.DEC[this.mode];\n        let hpos = AES_asm.HEAP_DATA;\n        let pos = this.pos;\n        let len = this.len;\n        let dpos = 0;\n        let dlen = data.length || 0;\n        let rpos = 0;\n        let rlen = (len + dlen) & -16;\n        let plen = 0;\n        let wlen = 0;\n        if (this.padding) {\n            plen = len + dlen - rlen || 16;\n            rlen -= plen;\n        }\n        const result = new Uint8Array(rlen);\n        while (dlen > 0) {\n            wlen = _heap_write(heap, pos + len, data, dpos, dlen);\n            len += wlen;\n            dpos += wlen;\n            dlen -= wlen;\n            wlen = asm.cipher(amode, hpos + pos, len - (!dlen ? plen : 0));\n            if (wlen)\n                result.set(heap.subarray(pos, pos + wlen), rpos);\n            rpos += wlen;\n            if (wlen < len) {\n                pos += wlen;\n                len -= wlen;\n            }\n            else {\n                pos = 0;\n                len = 0;\n            }\n        }\n        this.pos = pos;\n        this.len = len;\n        return result;\n    }\n    AES_Decrypt_finish() {\n        let { heap, asm } = this.acquire_asm();\n        let amode = AES_asm.DEC[this.mode];\n        let hpos = AES_asm.HEAP_DATA;\n        let pos = this.pos;\n        let len = this.len;\n        let rlen = len;\n        if (len > 0) {\n            if (len % 16) {\n                if (this.hasOwnProperty('padding')) {\n                    throw new IllegalArgumentError('data length must be a multiple of the block size');\n                }\n                else {\n                    len += 16 - (len % 16);\n                }\n            }\n            asm.cipher(amode, hpos + pos, len);\n            if (this.hasOwnProperty('padding') && this.padding) {\n                let pad = heap[pos + rlen - 1];\n                if (pad < 1 || pad > 16 || pad > rlen)\n                    throw new SecurityError('bad padding');\n                let pcheck = 0;\n                for (let i = pad; i > 1; i--)\n                    pcheck |= pad ^ heap[pos + rlen - i];\n                if (pcheck)\n                    throw new SecurityError('bad padding');\n                rlen -= pad;\n            }\n        }\n        const result = new Uint8Array(rlen);\n        if (rlen > 0) {\n            result.set(heap.subarray(pos, pos + rlen));\n        }\n        this.pos = 0;\n        this.len = 0;\n        this.release_asm();\n        return result;\n    }\n}\n","import { AES } from './aes';\nimport { joinBytes } from '../other/utils';\nexport class AES_CFB {\n    static encrypt(data, key, iv) {\n        return new AES_CFB(key, iv).encrypt(data);\n    }\n    static decrypt(data, key, iv) {\n        return new AES_CFB(key, iv).decrypt(data);\n    }\n    constructor(key, iv, aes) {\n        this.aes = aes ? aes : new AES(key, iv, true, 'CFB');\n        delete this.aes.padding;\n    }\n    encrypt(data) {\n        const r1 = this.aes.AES_Encrypt_process(data);\n        const r2 = this.aes.AES_Encrypt_finish();\n        return joinBytes(r1, r2);\n    }\n    decrypt(data) {\n        const r1 = this.aes.AES_Decrypt_process(data);\n        const r2 = this.aes.AES_Decrypt_finish();\n        return joinBytes(r1, r2);\n    }\n}\n","// This is only used in `decryptLegacy`\nimport { AES_CFB } from '@openpgp/asmcrypto.js/dist_es8/aes/cfb';\n\nexport const AES256 = {\n    blockSize: 16,\n    decrypt: (message, key, iv) => AES_CFB.decrypt(message, key, iv)\n};\n","export class IllegalStateError extends Error {\n    constructor(...args) {\n        super(...args);\n        Object.create(Error.prototype, { name: { value: 'IllegalStateError' } });\n    }\n}\nexport class IllegalArgumentError extends Error {\n    constructor(...args) {\n        super(...args);\n        Object.create(Error.prototype, { name: { value: 'IllegalArgumentError' } });\n    }\n}\nexport class SecurityError extends Error {\n    constructor(...args) {\n        super(...args);\n        Object.create(Error.prototype, { name: { value: 'SecurityError' } });\n    }\n}\n","const local_atob = typeof atob === 'undefined' ? (str) => require('buffer').Buffer.from(str, 'base64').toString('binary') : atob;\nconst local_btoa = typeof btoa === 'undefined' ? (str) => require('buffer').Buffer.from(str, 'binary').toString('base64') : btoa;\nexport function string_to_bytes(str, utf8 = false) {\n    var len = str.length, bytes = new Uint8Array(utf8 ? 4 * len : len);\n    for (var i = 0, j = 0; i < len; i++) {\n        var c = str.charCodeAt(i);\n        if (utf8 && 0xd800 <= c && c <= 0xdbff) {\n            if (++i >= len)\n                throw new Error('Malformed string, low surrogate expected at position ' + i);\n            c = ((c ^ 0xd800) << 10) | 0x10000 | (str.charCodeAt(i) ^ 0xdc00);\n        }\n        else if (!utf8 && c >>> 8) {\n            throw new Error('Wide characters are not allowed.');\n        }\n        if (!utf8 || c <= 0x7f) {\n            bytes[j++] = c;\n        }\n        else if (c <= 0x7ff) {\n            bytes[j++] = 0xc0 | (c >> 6);\n            bytes[j++] = 0x80 | (c & 0x3f);\n        }\n        else if (c <= 0xffff) {\n            bytes[j++] = 0xe0 | (c >> 12);\n            bytes[j++] = 0x80 | ((c >> 6) & 0x3f);\n            bytes[j++] = 0x80 | (c & 0x3f);\n        }\n        else {\n            bytes[j++] = 0xf0 | (c >> 18);\n            bytes[j++] = 0x80 | ((c >> 12) & 0x3f);\n            bytes[j++] = 0x80 | ((c >> 6) & 0x3f);\n            bytes[j++] = 0x80 | (c & 0x3f);\n        }\n    }\n    return bytes.subarray(0, j);\n}\nexport function hex_to_bytes(str) {\n    var len = str.length;\n    if (len & 1) {\n        str = '0' + str;\n        len++;\n    }\n    var bytes = new Uint8Array(len >> 1);\n    for (var i = 0; i < len; i += 2) {\n        bytes[i >> 1] = parseInt(str.substr(i, 2), 16);\n    }\n    return bytes;\n}\nexport function base64_to_bytes(str) {\n    return string_to_bytes(local_atob(str));\n}\nexport function bytes_to_string(bytes, utf8 = false) {\n    var len = bytes.length, chars = new Array(len);\n    for (var i = 0, j = 0; i < len; i++) {\n        var b = bytes[i];\n        if (!utf8 || b < 128) {\n            chars[j++] = b;\n        }\n        else if (b >= 192 && b < 224 && i + 1 < len) {\n            chars[j++] = ((b & 0x1f) << 6) | (bytes[++i] & 0x3f);\n        }\n        else if (b >= 224 && b < 240 && i + 2 < len) {\n            chars[j++] = ((b & 0xf) << 12) | ((bytes[++i] & 0x3f) << 6) | (bytes[++i] & 0x3f);\n        }\n        else if (b >= 240 && b < 248 && i + 3 < len) {\n            var c = ((b & 7) << 18) | ((bytes[++i] & 0x3f) << 12) | ((bytes[++i] & 0x3f) << 6) | (bytes[++i] & 0x3f);\n            if (c <= 0xffff) {\n                chars[j++] = c;\n            }\n            else {\n                c ^= 0x10000;\n                chars[j++] = 0xd800 | (c >> 10);\n                chars[j++] = 0xdc00 | (c & 0x3ff);\n            }\n        }\n        else {\n            throw new Error('Malformed UTF8 character at byte offset ' + i);\n        }\n    }\n    var str = '', bs = 16384;\n    for (var i = 0; i < j; i += bs) {\n        str += String.fromCharCode.apply(String, chars.slice(i, i + bs <= j ? i + bs : j));\n    }\n    return str;\n}\nexport function bytes_to_hex(arr) {\n    var str = '';\n    for (var i = 0; i < arr.length; i++) {\n        var h = (arr[i] & 0xff).toString(16);\n        if (h.length < 2)\n            str += '0';\n        str += h;\n    }\n    return str;\n}\nexport function bytes_to_base64(arr) {\n    return local_btoa(bytes_to_string(arr));\n}\nexport function pow2_ceil(a) {\n    a -= 1;\n    a |= a >>> 1;\n    a |= a >>> 2;\n    a |= a >>> 4;\n    a |= a >>> 8;\n    a |= a >>> 16;\n    a += 1;\n    return a;\n}\nexport function is_number(a) {\n    return typeof a === 'number';\n}\nexport function is_string(a) {\n    return typeof a === 'string';\n}\nexport function is_buffer(a) {\n    return a instanceof ArrayBuffer;\n}\nexport function is_bytes(a) {\n    return a instanceof Uint8Array;\n}\nexport function is_typed_array(a) {\n    return (a instanceof Int8Array ||\n        a instanceof Uint8Array ||\n        a instanceof Int16Array ||\n        a instanceof Uint16Array ||\n        a instanceof Int32Array ||\n        a instanceof Uint32Array ||\n        a instanceof Float32Array ||\n        a instanceof Float64Array);\n}\nexport function _heap_init(heap, heapSize) {\n    const size = heap ? heap.byteLength : heapSize || 65536;\n    if (size & 0xfff || size <= 0)\n        throw new Error('heap size must be a positive integer and a multiple of 4096');\n    heap = heap || new Uint8Array(new ArrayBuffer(size));\n    return heap;\n}\nexport function _heap_write(heap, hpos, data, dpos, dlen) {\n    const hlen = heap.length - hpos;\n    const wlen = hlen < dlen ? hlen : dlen;\n    heap.set(data.subarray(dpos, dpos + wlen), hpos);\n    return wlen;\n}\nexport function joinBytes(...arg) {\n    const totalLenght = arg.reduce((sum, curr) => sum + curr.length, 0);\n    const ret = new Uint8Array(totalLenght);\n    let cursor = 0;\n    for (let i = 0; i < arg.length; i++) {\n        ret.set(arg[i], cursor);\n        cursor += arg[i].length;\n    }\n    return ret;\n}\n"],"names":["AES_asm","gexp3","glog3","ginit_done","gmul","a","b","c","aes_sbox","aes_sinv","aes_enc","aes_dec","aes_init_done","aes_init","_s","s","x","i","ginv","d","ginit","t","wrapper","foreign","buffer","heap","Uint32Array","set","asm","stdlib","S0","S1","S2","S3","I0","I1","I2","I3","N0","N1","N2","N3","M0","M1","M2","M3","H0","H1","H2","H3","R","HEAP","DATA","Uint8Array","_core","k","r","x0","x1","x2","x3","t1","t2","t3","y0","y1","y2","y3","_ecb_enc","_ecb_dec","_cbc_enc","_cbc_dec","_cfb_enc","_cfb_dec","_ofb","_ctr","_gcm_mac","z0","z1","z2","z3","set_rounds","set_state","s0","s1","s2","s3","set_iv","i0","i1","i2","i3","set_nonce","n0","n1","n2","n3","set_mask","m0","m1","m2","m3","set_counter","c0","c1","c2","c3","get_state","pos","get_iv","gcm_init","cipher","mode","len","ret","_cipher_modes","mac","_mac_modes","set_key","ks","k0","k1","k2","k3","k4","k5","k6","k7","ekeys","subarray","dkeys","rcon","j","jj","ENC","ECB","CBC","CFB","OFB","CTR","DEC","MAC","GCM","HEAP_DATA","heap_pool","asm_pool","AES","constructor","key","iv","padding","this","acquire_asm","undefined","pop","reset","release_asm","push","keylen","length","keyview","DataView","byteOffset","byteLength","getUint32","ivview","AES_Encrypt_process","data","TypeError","amode","hpos","dpos","dlen","rpos","wlen","result","AES_Encrypt_finish","plen","rlen","hasOwnProperty","p","AES_Decrypt_process","AES_Decrypt_finish","pad","pcheck","AES_CFB","encrypt","decrypt","aes","r1","r2","AES256","blockSize","message","IllegalStateError","Error","args","super","Object","create","prototype","name","value","IllegalArgumentError","SecurityError","atob","btoa","is_bytes","_heap_init","heapSize","size","ArrayBuffer","_heap_write","hlen","joinBytes","arg","totalLenght","reduce","sum","curr","cursor"],"sourceRoot":""}